// Generated by CoffeeScript 1.3.3
(function() {
  var getId, isBrowser, vein,
    _this = this,
    __slice = [].slice;

  isBrowser = typeof window !== 'undefined';

  getId = function() {
    var rand;
    rand = function() {
      return (((1 + Math.random()) * 0x10000000) | 0).toString(16);
    };
    return rand() + rand() + rand();
  };

  vein = {
    options: {
      namespace: 'Vein',
      resource: 'default'
    },
    start: function() {
      this.services = {};
      return this.callbacks = {};
    },
    inbound: function(socket, msg, done) {
      try {
        return done(JSON.parse(msg));
      } catch (err) {
        return this.error(socket, err);
      }
    },
    outbound: function(socket, msg, done) {
      try {
        return done(JSON.stringify(msg));
      } catch (err) {
        return this.error(socket, err);
      }
    },
    validate: function(socket, msg, done) {
      if (typeof msg !== 'object') {
        return done(false);
      }
      if (typeof msg.type !== 'string') {
        return done(false);
      }
      if (msg.type === 'response') {
        if (typeof msg.id !== 'string') {
          return done(false);
        }
        if (typeof this.callbacks[msg.id] !== 'function') {
          return done(false);
        }
        if (typeof msg.service !== 'string') {
          return done(false);
        }
        if (!Array.isArray(msg.args)) {
          return done(false);
        }
      } else if (msg.type === 'cookie') {
        if (typeof msg.key !== 'string') {
          return done(false);
        }
        if ((msg.args != null) && typeof msg.args !== 'string') {
          return done(false);
        }
      } else if (msg.type === 'services') {
        if (!Array.isArray(msg.args)) {
          return done(false);
        }
      } else {
        return done(false);
      }
      return done(true);
    },
    error: function(socket, err) {
      throw err;
    },
    message: function(socket, msg) {
      var k, _i, _len, _ref, _ref1;
      if (msg.type === 'response') {
        return (_ref = this.callbacks)[msg.id].apply(_ref, msg.args);
      } else if (msg.type === 'cookie') {

      } else if (msg.type === 'services') {
        this.services = msg.args;
        _ref1 = this.services;
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          k = _ref1[_i];
          this[k] = this.getSender(socket, k);
        }
        return this.emit('ready', this.services);
      }
    },
    getSender: function(socket, service) {
      var _this = this;
      return function() {
        var args, cb, id, _i;
        args = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), cb = arguments[_i++];
        id = getId();
        _this.callbacks[id] = cb;
        return socket.write({
          type: 'request',
          id: id,
          service: service,
          args: args,
          cookies: {}
        });
      };
    }
  };

  window.Vein = {
    create: function(opt) {
      var k, v;
      if (opt == null) {
        opt = {};
      }
      for (k in opt) {
        v = opt[k];
        vein.options[k] = v;
      }
      return ProtoSock.createClient(vein);
    }
  };

}).call(this);
